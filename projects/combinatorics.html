<!DOCTYPE html>
<html lang="en">
  <head>
    <!--
                                      _
        /\     _             _   _   | |             __    __
       /  \   | |      /\   | \ | |  | |       /\   |  \  /  |
      /    \  | |     /  \  |  \| |  | |      /  \  | |\\//| |
     / ____ \ | |__  / __ \ | |\  |  | |___  / __ \ | | \/ | |
    /_/    \_\|____|/_/  \_\|_| \_|  |_____|/_/  \_\|_|    |_|
    -->
    <title>Alan Lam | Combinatorics</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <link rel="shortcut icon" type="image/png" href="../pictures/favicon.ico"/>
    <link href="styles.css" rel="stylesheet">
  </head>
  <body>
    <div class="dropdown">
      <button onclick="showMenu()" class="dropbtn">ToC</button>
      <div class="dropdown-content" id="dropDownMenu">
        <a class="dropdown-item" href="#permutations">Permutations</a>
        <a class="dropdown-item" href="#combinations">Combinations</a>
        <a class="dropdown-item" href="#words">Words</a>
        <a class="dropdown-item" href="#choiceproblems">Choice Problems</a>
        <a class="dropdown-item" href="#multisets">Multisets</a>
        <a class="dropdown-item" href="#poker">Counting Poker Hands</a>
        <a class="dropdown-item" href="#compositions">Compositions</a>
        <a class="dropdown-item" href="#setpartitions">Set Partitions</a>
      </div>
    </div>
    <div class="container line-height">
      <a href="projects.html"><i class="fas fa-long-arrow-alt-left fa-2x"></i></a>
      <div class="row">
        <div class="col-12">
          <h1>Combinatorics</h1>
          <hr>
          <p>Shortcut to this page: <a href="nonlinear.html">aln.netlify.com/comb</a></p>
          <h2 id="permutations">Permutations</h2>
          <div class="box">
            <p>Given a set `S` of objects, a <b>permutation</b> of `S` is a way to put all elements of `S` in order</p>
          </div>
          <div class="box">
            <p>For `S = {1,2,3}`, all the permutations are:</p>
            <div class="math">
              <p>`1,2,3`</p>
              <p>`1,3,2`</p>
              <p>`2,1,3`</p>
              <p>`2,3,1`</p>
              <p>`3,1,2`</p>
              <p>`3,2,1`</p>
            </div>
          </div>
          <div class="box">
            <p>Theorem: If `S` has `n gt 0` elements, then there are `n!` permutations of the elements in `S`</p>
            <div class="collapse" id="permutationproof">
              <p>For a set of size `1`, there's only `1` way to order all the elements. `1 = 1!` so the statement holds for the base case</p>
              <p>Suppose the statement is true for a set of size `n`</p>
              <p>Let `S` be a set of size `n+1`</p>
              <p>We could pick any random element of `S` and put that in the first spot</p>
              <p>Now, `S` has `n` elements</p>
              <p>Since the statement is true for a set of size `n`, there are `n!` ways to order the remaining elements in `S`</p>
              <p>There were `n+1` choices for the random element in the first spot</p>
              <p>So the total number of ways to order the elements is `(n+1)*n! = (n+1)!`</p>
            </div>
            <a class="btn" data-toggle="collapse" href="#permutationproof">Proof</a>
            <p>Intuitively, there are `n` choices for the first digit, `n-1` choices for the second digit, `n-2` choices for the third digit, ..., all the way down to `1` choice for the last digit</p>
            <p>So there are `n*(n-1)*(n-2)*...*1 = n!` ways to order the elements</p>
          </div>
          <h2 id="combinations">Combinations</h2>
          <p>Let's suppose you're arranging flowers. You have `2` red flowers and `1` yellow flower. How many ways can we arrange them? Previously, we saw that if we have `n` elements, there are `n!` ways to arrange them. Here, we have `3` elements, so there are `3! = 6` ways to arrange them. All the possible orderings are:</p>
          <div class="math">
            <p>`R RY`</p>
            <p>`R RY`</p>
            <p>`YR R`</p>
            <p>`YR R`</p>
            <p>`RYR`</p>
            <p>`RYR`</p>
          </div>
          <p>But some of the orderings are repeated. This is because the `2` red flowers are technically different flowers, but the order in which they appear doesn't matter; the result is the same. So we have to divide out the commonalities. In this case, since there are `2` red flowers and, therefore, `2!` ways to order them, we divide the total number of ways to arrange all the elements by `2!`.</p>
          <div class="math">
            <p>`(3!)/(2!) = 3`</p>
            <p>`R RY`</p>
            <p>`YR R`</p>
            <p>`RYR`</p>
          </div>
          <div class="box">
            <p>If we have `10` red flowers and `5` yellow flowers, then the total number of ways to arrange them is</p>
            <div class="math">
              <p>`(15!)/(10!5!)`</p>
            </div>
          </div>
          <div class="box">
            <p>If we have `r` red flowers, `y` yellow flowers, and `b` blue flowers, then the total number of ways to arrange them is</p>
            <div class="math">
              <p>`((r+y+b)!)/(r!y!b!)`</p>
            </div>
          </div>
          <div class="box">
            <p>Theorem: Say we have `n` objects which have one of `k` different types. Objects of the same type are considered identical. Label the types with numbers `1,2,...,k` and let `a_i` be the number of objects of type `i`. Then the number of ways to arrange the `n` objects is `(n!)/(a_1!a_2!...a_k!)`</p>
          </div>
          <div class="box">
            <p>The <b>multinomial coefficient</b> is `((n),((a_1,a_2,...,a_k))) = (n!)/(a_1!a_2!...a_k!)`</p>
            <p>The <b>binomial coefficient</b> is the multinomial coefficient for `k=2`, which is `((n),((a_1,a_2)))`. It's often denoted by `((n),(a_1))` instead because we know `a_2 = n - a_1`</p>
          </div>
          <h2 id="words">Words</h2>
          <p>Sometimes, it's easier to count things by using some sort of encoding.</p>
          <div class="box">
            <p>A <b>word</b> is a finite ordered sequence whose entries are drawn from some set `A`, called the alphabet. The <b>length</b> of a word is the number of entries it has. Entries may be repeated. An empty sequence `O/` is a word of length `0`</p>
          </div>
          <div class="box">
            <p>The alphabet is `A = {a,b}`</p>
            <p>The words of length `le 2` are:</p>
            <div class="math">
              <p>`O/`</p>
              <p>`a`</p>
              <p>`b`</p>
              <p>`aa`</p>
              <p>`ab`</p>
              <p>`ba`</p>
              <p>`bb`</p>
            </div>
          </div>
          <div class="box">
            <p>Theorem: If `|A| = n`, then the number of words of length `k` is `n^k`</p>
            <p>Since there are `n` choices for each spot and there are `k` spots, there are `ubrace(n*n*...*n)_k = n^k` words of length `k`</p>
          </div>
          <div class="box">
            <p>`[n] = {1,2,...,n}`</p>
          </div>
          <div class="box">
            <p>The number of subsets of `[n]` is `2^n`</p>
            <div class="collapse" id="subsetwordproof">
              <p>Let `S sube [n]`</p>
              <p>Define a word `w_s` of length `n` in the alphabet `{0,1}` as follows:</p>
              <p>Let `i in [n]`</p>
              <p>If `i in S`, then the `i^(th)` entry of `w_s = 1`</p>
              <p>If `i notin S`, then the `i^(th)` entry of `w_s = 0`</p>
              <p>We have a function `f:{text(subset ) S text( of ) [n]} rarr {text(word of length ) n text( in alphabet ) {0,1}}`</p>
              <p>We can define another function `g:{text(words of length ) n text( in ) {0,1}} rarr {text(subset of ) [n]}` to be the inverse of `f`</p>
              <p>This means `f` is bijective</p>
              <p>So `|{text(subsets of )[n]}| = |{text(words of length )n text( in ) {0,1}}| = 2^n`</p>
              <div class="box">
                <p>If `n = 5` and `S = {1,3,4}`, then the word associated with `S` is `10110`</p>
              </div>
            </div>
            <a class="btn" data-toggle="collapse" href="#subsetwordproof">Proof</a>
            <p>The general idea is that any element is either in `S` or not in `S`</p>
          </div>
          <div class="box">
            <p>How many pairs of subsets `S,T sube [n]` satisfy `S sube T`?</p>
            <p>A similar idea applies here: any element is</p>
            <ol>
              <li>in `S` and in `T`</li>
              <li>not in `S` but in `T`</li>
              <li>not in `S` and not in `T`</li>
            </ol>
            <p>There are `3` choices for each of the `n` elements, so there are `3^n` total possibilities</p>
            <p>We could define a function `f:{text(pairs of subsets ) S,T sube [n] s.t. S sube T} rarr {text(words of length ) n text( in ) {text(in ) S, text( not in ) S text( but in ) T, text( not in ) S text( and not in ) T}}`</p>
          </div>
          <div class="box">
            <p>For `n ge k` where `n` is a nonnegative integer, the <b>falling factorial</b> is `(n)_k = n*(n-1)*(n-2)*...*(n-k+1)`</p>
            <p>`(6)_3 = 6*5*4`</p>
            <p>`(6)_6 = 6*5*4*3*2*1`</p>
          </div>
          <div class="box">
            <p>Theorem: If `|A| = n ge k`, then there are `(n)_k` words of length `k` in `A` that do not have repeating entries</p>
            <div class="collapse" id="repeatingentriesproof">
              <p>Let `sigma = a_1a_2...a_ka_(k+1)...a_n` be a permutation of `A`</p>
              <p>The first `k` entries make up a word with no repeating entries</p>
              <p>Since there are `n!` permutations, we have `n!` words with no repeating entries</p>
              <p>But there are repeated words since the last `(n-k)` entries can be ordered in any way</p>
              <p>So there are `(n!)/((n-k)!) = (n*(n-1)*...*(n-k+1)*(n-k)!)/((n-k)!) = (n)_k` words with no repeating entries</p>
              <p>For example, let `A = {1,2,3,4,5}` and `k=3`</p>
              <p>Let `sigma = 31254`</p>
              <p>The first `k` entries are `312`, which is a word of length `k` with no repeating entries</p>
              <p>So that is contained in `31254`</p>
              <p>But that same word is also contained in `31245`</p>
            </div>
            <a class="btn" data-toggle="collapse" href="#repeatingentriesproof">Proof</a>
            <p>Intuitively, there are `n` choices for the first digit, `n-1` choices for the second digit, ..., `n-k+1` choices for the `k^(th)` digit</p>
          </div>
          <h2 id="choiceproblems">Choice Problems</h2>
          <p>We saw earlier that the number of subsets of a set of size `n` is `2^n`. We could look at how many of those subsets are of size `k`.</p>
          <div class="box">
            <p>Theorem: The number of `k`-element subsets of `[n]` is `((n),(k)) = (n!)/(k!(n-k)!)`</p>
            <div class="collapse" id="kelementsubsets">
              <p>We can associate subsets of `[n]` with words of length `n` in `{0,1}`</p>
              <p>The number of `k`-element subsets of `[n]` is the number of words of length `n` in `{0,1}` that have exactly `k` `1`'s</p>
              <p>For such words, there are `k` ways to arrange the `1`'s and `n-k` ways to arrange the `0`'s</p>
              <p>Which gives us `(n!)/(k!(n-k)!) = ((n),(k))`</p>
            </div>
            <a class="btn" data-toggle="collapse" href="#kelementsubsets">Proof</a>
          </div>
          <div class="box">
            <p>Corollary: `sum_(k=0)^n ((n),(k)) = 2^n`</p>
            <div class="collapse" id="sumofsubsets">
              <p>`sum_(k=0)^n ((n),(k))` is the number of ways to choose subsets of size `0`, `1`, `2`, ..., `n`</p>
              <p>Well, that should make up all the possible subsets</p>
              <p>Before, we showed that the total number of subsets is `2^n`</p>
            </div>
            <a class="btn" data-toggle="collapse" href="#sumofsubsets">Proof</a>
          </div>
          <div class="box">
            <p>Pascal's Identity: For any `k ge 0`, `((n),(k-1)) + ((n),(k)) = ((n+1),(k))`</p>
            <div class="collapse" id="pascalsidentity">
              <p>`((n+1),(k))` is the number of `k`-element subsets of `[n+1]`</p>
              <p>We could split those subsets up into two categories: subsets of size `k` that contain `n+1` and subsets of size `k` that don't contain `n+1`</p>
              <div class="math">
                <img class="img-fluid" src="../pictures/combinatorics/pascal_1.jpg">
              </div>
              <p>The subsets of size `k` that don't contain `n+1` are actually the subsets of size `k` of `[n]`, so that gives us `((n),(k))`</p>
              <div class="math">
                <img class="img-fluid" src="../pictures/combinatorics/pascal_2.jpg">
              </div>
              <p>If we look at the subsets of size `k` that do contain `n+1` and remove `n+1` from each subset, we end up with the number of subsets of size `k-1` of `[n]`, which gives us `((n),(k-1))`</p>
              <div class="math">
                <img class="img-fluid" src="../pictures/combinatorics/pascal_3.jpg">
              </div>
            </div>
            <a class="btn" data-toggle="collapse" href="#pascalsidentity">Proof</a>
          </div>
          <h2 id="multisets">Multisets</h2>
          <p>Multisets are like subsets except the elements can be repeated.</p>
          <div class="box">
            <p>Multisets of `{1,2,3}` of size `3` are:</p>
            <div class="math">
              <p>`{1,1,1}`</p>
              <p>`{1,1,2}`</p>
              <p>`{1,1,3}`</p>
              <p>`{1,2,2}`</p>
              <p>`{1,2,3}`</p>
              <p>`{1,3,3}`</p>
              <p>`{2,2,2}`</p>
              <p>`{2,2,3}`</p>
              <p>`{2,3,3}`</p>
              <p>`{3,3,3}`</p>
            </div>
            <p>Are these all the possible multisets? How can we be sure?</p>
            <p>Let's add `1` to the `2^(nd)` element and add `2` to the `3^(rd)` element.</p>
            <div class="math">
              <p>`{1,1,1} rarr {1,2,3}`</p>
              <p>`{1,1,2} rarr {1,2,4}`</p>
              <p>`{1,1,3} rarr {1,2,5}`</p>
              <p>`{1,2,2} rarr {1,3,4}`</p>
              <p>`{1,2,3} rarr {1,3,5}`</p>
              <p>`{1,3,3} rarr {1,4,5}`</p>
              <p>`{2,2,2} rarr {2,3,4}`</p>
              <p>`{2,2,3} rarr {2,3,5}`</p>
              <p>`{2,3,3} rarr {2,4,5}`</p>
              <p>`{3,3,3} rarr {3,4,5}`</p>
            </div>
            <p>Notice that we end up with all the subsets of size `3` of `[5]`. This leads to a more general result.</p>
          </div>
          <div class="box">
            <p>Theorem: The number of `k`-element multisets of a set of size `n` is `((n+k-1),(k))`</p>
            <div class="collapse" id="multisets">
              <p>Note: it doesn't matter what the set is, since we can form a bijection between the set and `[n]`</p>
              <p>Let `S` be a multiset of size `k` of `[n]`</p>
              <p>Sort the elements of `S` so that `s_1 le s_2 le s_3 le ... le s_k`</p>
              <p>Add `i-1` to each `s_i`</p>
              <p>Then we get `s_1 lt s_2 + 1 lt s_3 + 2 lt ... lt s_k + (k-1)`</p>
              <p>Well, `{s_1, s_2+1, s_3+2, ..., s_k+(k-1)}` is a subset of size `k` of `[n+k-1]color(red)(text(*))`</p>
              <p>The number of ways to make `k`-element subsets from a set of size `[n+k-1]` is `((n+k-1),(k))`</p>
              <p>(Reversing the process -- subtracting `i-1` from each `s_i` -- shows that there is a bijection between `{s_1, s_2, ..., s_k}` and `{s_1, s_2+1, ..., s_k+(k-1)}`)</p>
              <p>`color(red)(text(*))` happens when `s_k = n`</p>
            </div>
            <a class="btn" data-toggle="collapse" href="#multisets">Proof</a>
          </div>
          <div class="box">
            <p>Let `x`,`y`,`z` be variables. `deg(x^a,y^b,z^c) = a+b+c` and `a,b,c ge 0`</p>
            <p>How many products have degree `d`?</p>
            <div class="math">
              <p>`d = 1:`</p>
              <p>`x, y, z` (`3`)</p>
              <p>`d = 2:`</p>
              <p>`x^2, y^2, z^2, xy, xz, yz` (`6`)</p>
              <p>`d = 3:`</p>
              <p>`x^3, y^3, z^3, x^2y, x^2z, y^2x, y^2z, z^2x, z^2y, xyz` (`10`)</p>
            </div>
            <p>`x^ay^bz^c` is a multiset of `{x,y,z}` where `x` appears `a` times, `y` appears `b` times, and `z` appears `c` times</p>
            <p>So the total number of products is the number of multisets of size `d` of `{x,y,z}`, which is `((d+2),(d))`</p>
          </div>
          <div class="box">
            <p>`x_1^(a_1)x_2^(a_2)...x_n^(a_n)` is a multiset of `{x_1,x_2,...,x_n}` where `x_i` is chosen `a_i` times</p>
            <p>The total number of products `x_1^(a_1)*...*x_n^(a_n)` with `a_1 + ... + a_n = d` is the number of multisets of size `d` of a set of size `n`, which is `((n+d-1),(d))`</p>
          </div>
          <h2 id="poker">Counting Poker Hands</h2>
          <div class="box">
            <p>Four of a Kind: `4` of the `5` cards have the same value</p>
            <p>There are `13` choices for the value that is the same</p>
            <p>There are `48` choices for the `5^(th)` card</p>
            <p>Total number of ways to get a four of a kind: `13*48`</p>
          </div>
          <div class="box">
            <p>Full House: `3` cards have the same value and `2` cards have the same value</p>
            <p>There are `13` choices for the value of the triple</p>
            <p>There are `12` choices for the value of the pair</p>
            <p>There are `((4),(3))` choices for the suits of the triple</p>
            <p>There are `((4),(2))` choices for the suits of the pair</p>
            <p>Total number of ways to get a full house: `13*12*((4),(3))*((4),(2))`</p>
          </div>
          <div class="box">
            <p>Two Pair: `2` cards have the same value, `2` cards have the same value, `1` card has a different value</p>
            <p>There are `((13),(2))` choices for the value of one pair</p>
            <p>There are `((4),(2))` choices for suits of one pair</p>
            <p>There are `((4),(2))` choices for suits of other pair</p>
            <p>There are `44` choices for the leftover card</p>
            <p>Total number of ways to get a two pair: `((13),(2))*((4),(2))*((4),(2))*44`</p>
          </div>
          <div class="box">
            <p>Straight: `5` cards can be put in consecutive order by values</p>
            <p>To pick values, we only need to know what the largest possible values are</p>
            <p>The `5^(th)` card can be `5`, `6`, `7`, `8`, `9`, `10`, `J`, `Q`, `K`, or `A`</p>
            <p>There are `10` choices for the `5^(th)` card</p>
            <p>There are `4^5` choices for the suits of each card</p>
            <p>Total number of ways to get a straight: `10*4^5`</p>
          </div>
          <h2 id="compositions">Compositions</h2>
          <h2 id="setpartitions">Set Partitions</h2>
        </div> <!-- col -->
      </div> <!-- row -->
    </div> <!-- container -->
    <script>
      function showMenu() {
        document.getElementById("dropDownMenu").classList.toggle("show");
      }
      window.onclick = function(event) {
        if (!event.target.matches('.dropbtn')) {
          var dropdowns = document.getElementsByClassName("dropdown-content");
          var i;
          for (i = 0; i < dropdowns.length; i++) {
            var openDropdown = dropdowns[i];
            if (openDropdown.classList.contains('show')) {
              openDropdown.classList.remove('show');
            }
          }
        }
      }
    </script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
  </body>
</html>
